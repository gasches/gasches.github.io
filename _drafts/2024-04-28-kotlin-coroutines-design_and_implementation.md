---
layout: post
title:  Kotlin Coroutines: Design and Implementation
date:   2024-04-28 00:00:00 +0000
categories: kotlin coroutines
---
> Roman Elizarov, Mikhail Belyaev, Marat Akhin, and Ilmir Usmanov. 2021. Kotlin Coroutines: Design and Implementation. In Proceedings of the 2021 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (Onward! ’21), October 20–22, 2021, Chicago, IL, USA. ACM, New York, NY, USA, 17 pages. https://doi.org/10.1145/3486607.3486751. Вольный перевод

* TOC:
{:toc}

## Aннотация

Асинхронное программирование переживает ренессанс в последние годы. Созданное в 1980-х оно применялось довольно долгое время, но с появлением многоядерных процессоров было вытеснено многопоточным программированием, которое (на очень долгое время) фактически стало стандартном для реализации параллельных вычислений. Однако, начиная с 2000-х, все больше языков программрования начали поддерживать асинхронность. Некоторые - с самого начала, в то время как другие внедряли поддержку в ходе развития.

В этой статье исследуются дизайн и реализация асинхронного программирования в [Kotlin][kotlin] - мультиплатформенном языке программирования от JetBrains, в котором асинхронность реализована с помощью [корутин (coroutines, сопрограмма)][kcoroutines]. Koltin предоставляет компактный встроенный API для поддержки корутин давая разработчику большую свободу для имплементации. Эта гибкость делает возможной _прозрачную_ поддержку различных вариантов реализации асинхронного программирования в рамках одного языка.

В статье кратко рассмотрены существующие подходы к асинхронному программированию, а основной упор сделан на корутины как основу реализации асинхронных вычислений в Kotlin. В ходе исследования будет показана гибкость корутин в Kotlin, освещены некоторые существующие проблемы асинхронного программирования и то как с ними справляется Kotlin. Также будут упомянуты перспективные направления в исследовании асинхронного программирования.

## 1 Введение

Рациональное использование аппаратных средств давно является одной из главных проблем программирования.
Для эффективной утилизации современных процессоров наши программы (среди прочего) должны поддерживать одновременное выполнение нескольких вычислений: пока одни делают полезную работу, другие могут ждать данных или результатов других вычислений.

Многопоточность (multithreading) традиционно применялась для распараллеливания вычислений, когда каждое такое вычисление выполняется в отдельном потоке (thread).
Если вычислению нужно подождать чего-то, то поток блокируется для освобождения ресурсов процессора, и позже возобновляется когда необходимые результаты уже готовы.
Хотя такая модель и решает проблему, она имеет несколько недостатков, таких как сложность программирования и снижение производительности для задач, связанных с вводом-выводом (IO-bound).

Альтернативой многопоточности являются различные виды асинхронного программирования.
В отличие от многопоточности, которая основана на гомогенных (coarse-grained) потоках, асинхронное программирование реализовано средствами гетерогенных (fine-grained) приостанавливаемых (suspendable) вычислений, которые могут эффективно переплетаться друг с другом (обеспечивая лучший уровень конкурентности (concurrency)).
Однородный, однообразный
Многие из ранних языков программирования имели поддержку асинхронного программирования, но с распространением многоядерных процессоров она была практически полностью вытеснена многопоточностью.

Однако, в последние годы наступил момент своего рода "ренессанса", так как всё больше языков начали опять включать поддержку асинхронного программирования.
Причиной этому может быть то, что оно лучше подходит для современных приложений которым приходится много ждать: ввода данных пользователем, сетевых пакетов и т.д.
Языки программирования поддерживают асинхронность по-разному, в зависимости от целей дизайна и их эволюции.

В этой статье исследуются дизайн и реализация асинхронного програмирования в [Kotlin][kotlin] - мультиплатформенном языке программирования от JetBrains, в котором асинхронность реализована с помощью [корутин (coroutines)][kcoroutines].
Его поддержка аснхронного программирования в некоторой степени уникальна, потому что сам Kotlin предоставляет компактный набор встроенного асинхронного API, а бОльшая часть реализации представлена в виде пользовательских библиотек.
Эта позволяет поддержать различные виды асинхронного программирования в рамках одного языка, давая разработчику большую свободу для имплементации.

Оставшаяся часть статьи реализована следующим образом.
Во втором разделе рассматриваются существующие подходы для асинхронного программирования и их проблемы.
В третьем разделе сделан фокус на корутинах.
В четвёртом разделе производится анализ дизайна и реализации корутин в Kotlin, а в пятом - приведены множество примеров гибкости выбранного подхода.
После этого в разделе 6 рассмотрены текущие ограничения, а в седьмом - открытые вопросы дизайна.

2 Способы реализации асинхронного программирования

На протяжении многих лет предпринимались попытки снабдить языки программирования средствами для поддержки асинхронности.
Здесь, чтобы предоставить контекст для лучшего понимания дизайна и реализации корутин в Kotlin, мы рассмотрим наиболее важные из них.

2.1 Callbacks (функции обратного вызова)

Callback-и - это, пожалуй, самый распространенный способ организации программ с асинхронными вычислениями.
По сути - это функция передаваемая (как лямбда-выражение, ссылка, указатель и т.д.) соответствующему API с намерением быть вызванной при выполнении некоторого условия (например, готовности результата асинхронного вычисления).
Callback-и могут использоваться для поддержки как синхронных (например, для обработки ошибок) так и асинхронных моделей выполнения.
Они особенно широко распространены в системном программировании как средство для взаимодействия с асинхронным API предоставляемым операционной системой, таким как сигналы Unix.

Callback-и удобны для выражения отдельных асинхронных взаимодействий в синхронном коде.
Однако, в более сложных сценариях, фреймворки основанные на callback-ах как известно приводят к такому усложнению структуры кода, что оно несоответствует сложности логики, которую этот код выражает (так называемый "callback hell").
Это особенно заметно в языках программирования с поддержкой анонимных или локальных функций где _callback hell_ приводит к глубоко вложенной структуре и/или множеству небольших именованных локальных функций, которые очень трудно поддерживать или изменять.
Пример того как API основанный на обратных вызовах приводит к появлению вложенного и сложного кода, приведён в листинге 1.

```javascript
fs.listDirectory(target) { files ->
    for (file in files) {
        file.readText { text ->
            sendMessage(peer, text) { answer ->
                database.store(answer) { result ->
                    if (result.error) error (result.error)
                }
                sendMessage (leader, 'done') { answer ->
                    log(answer)
                }
            }
        }
    }
}
```

Callback-и, при этом, имеют одно очень важное преимущество перед другими подходами к асинхронному программированию: фреймворки, основанные на обратных вызовах, гораздо проще в реализации и использовании при отсутствии явной поддержки со стороны языка.

2.2 Futures/Promises

Future-и или promise-ы (также иногда называемые deferred-ами or task-ами) стоят на ступень выше вычислений на основе callback-ов, работая как специальные прокси для еще не завершённых результатов асинхронных вычислений.
Базовый, но при этом полный набор операций, которые можно выполнить над promise-ом, состоит из двух:
* проверки на завершение и
* получении конечного результата.
Попытка получить результат ещё не завершённого promise-а, в зависимости от реализации, либо блокирует выполнение программы до тех пор, пока результат не будет готов, либо приводит к ошибке времени выполнения.

Хотя оба термина используются взаимозаменяемо кажется, что термин future более распространён для прокси-объектов с результатом доступным только для чтения, в то время как promise - для прокси-объектов которые можно завершить (fulfil) извне.
Здеь и далее термин promise будет использоваться для описания прокси обоих типов.

Основная проблема приведенных выше _базовых_ promise-ов заключается в неспособности простым способом выразить полностью асинхронные вычисления: имея базовый набор операций приходиться или синхронно блокировать выполнение ожидая завершение каждого из promise-ов (что противоречит цели асинхронного программирования) или вводить собственную реализацию цикла обработки событий (event loop) в котором периодически проверять состояние активных promise-ов.
Это ведёт к загромождению пользовательского кода шаблонными конструкциями.

Расширением концепции promise-ов является их организация в виде конвеера (pipelining): этот термин был введен в обиход благодаря языку программирования Joule, но сама идея изначально сформулирована в [33].
Техника конвейеризации promise-ов вводит примитивы композиции, благодаря которым становится возможным создание составных результатов из различных асинхронных вычислений без явного ожидания каждого из них.
Такие примитивы могут включать запуск произвольного кода при завершении вычисления или создание нового результата из нескольких незавершённых (который будет вычислен при их завершении).
Те, кто имеет опыт использования функциональных языков программирования могут заметить, что конвейеризация даёт возможность promise-у реализовать функциональную монаду с дополнительной возможностью использовать существующий основанный на монадах шаблонный код.

С точки зрения программиста, конвейеризация promise-ов является смесью callback-ов и основанных на promise-ах вычислений, поскольку примитивы высшего порядка, используемые большинством вычислений с конвейерной обработкой, в качестве функции которую нужно запустить при готовности всех требуемых результатов принимают callback.
Тем не менее, это позволяет выражать "по-настоящему" асинхронные вычисления без использования явной блокировки или циклов обработки событий (event loops), также частично устраняя проблему "callback hell".

Пример который иллюстрировал "callback hell", но с использованием преимуществ конвейеризации promise-ов приведён в листинге 2.

```javascript
fs.listDirectory(dir)
    .thenApply { files ->
        files.map { file ->
            file.readText()
                .thenCompose { text ->
                    sendMessage(peer, text)
                }.thenCompose { answer ->
                    database.store(answer)
                }.thenRun { result ->
                    if (result.error) error(result.error)
                }.thenCompose { result ->
                    sendMessage(leader, 'done')
                }.thenApply { answer ->
                    log(answer)
                }
        }.let { allOf(it) }
}
```

В нём используются наименования из стандартной библиотеки Java 8 (а именно из класса `CompletableFuture`, который реализует конвейерный promise);
следуя традиционному наименованию API монад `thenApply` может быть заменён на `map`, а `thenCompose` - на `flatMap`.
Хотя версия функции на основе promise-ов длиннее, она лучше выражает отношения между операциями и является менее вложенной.
Однако она все ещё загромождена обеспечивающими асинхронность специфичными вызовами функций и ненужными лямбда-выражениями.

2.3 async/await

Естественным улучшением таких техник как callback-и and promise-и было бы сглаживание различий между синхронным и асинхронным кодом.
Асинхронный код обычно сложнее осмыслить, чем синхронный, а дополнительная многословность callback-ов and promise-ов (не будучи конструкциями языка программирования) делают ситуацию ещё хуже.
async/await - подход который лишён этих проблем, поскольку асинхронное программирование становится объектом первого класса (first-class citizen).

Подход async/await основан на представлении асинхронных вычислений в виде двух взаимосвязанных частей:
* `async` используется для обозначения кода (вызова функции, выражения, блока) который выполняется асинхронно;
* `await` действует в роли барьера для одного или нескольких `async`-блоков, гарантируя звершение их выполнения.

Первым широко используемым языком программирования, в котором появились `async`/`await`, был C# версии 5.0 (2012 год).
До C# подобная возможность появилась в F# версии 2.0 с его асинхронными выражениями, которые в свою очередь были вдохновлены работой над concurrency-монадой для Haskell.

В зависимости от варианта поддержки в языке, разные элементы должны быть помечены как async или await.
Например, в C# асинхронная функция, определяющая локаль веб-страницы, может выглядеть, как показано в листинге 3.
Реализация async/await в C# помечает код следующим образом:
* async - это модификатор обозначающий, что функция поддерживает асинхронное выполнение;
* await - это встроенный оператор, который ожидает завершения выполнения своего асинхронного аргумента.

В C# имеется два дополнительных ограничения касающихся его реализации async/await.
Во-первых, оператор await можно использовать только с async-функциями.
Во-вторых, возвращаемое значение async-функций должно быть ожидаемого типа, то есть типа с возможностями promise-а.

Если мы забудем об этих ограничениях и посмотрим на сам код, то увидим, что он выглядит как синхронный.
единственное, что намекает на его асинхронную природу, - это ключевые слова async/await.
Это одна из самых сильных сторон async/await по сравнению с другими подходами к асинхронному программированию: шаблонные конструкции (практически) отсутствует, код удобочитаем и его легко понять.

Многие языки программирования использовали подход C# в качестве вдохновения и следуют его реализации async/await.
JavaScript, TypeScript, Dart, Hack, Python, Rust - все эти языки используют async-функции, содержащие операторы await, которые работают с соответствующим типом promise-а.
C++20, с другой стороны, не имеет модификатора async, считая асинхронными все функции для которых используется выражение await, в то время как Kotlin выбрал обратное соглашение - с модификатором async (называемым suspend) и без встроенного оператора await.
Хотя мы еще вернёмся к этому решению в дизайне и попытаемся объяснить его в разделе 4.2, важно отметить, что, несмотря на эти различия, реализации C++ и Kotlin по-прежнему относятся к подходу async/await.

Поскольку подход к `async`/`await` в стиле C# требует, чтобы `async`-функция имела специальный тип возвращаемого значения, то `async`/`await` можно рассматривать просто как синтаксический _сахар_ над конвейеризацией promise-ов.
Однако, как только мы начнём рассматривать сложные виды порядка выполнения (например, циклы или обработку исключений) удаления синтаксического сахара (desugaring) вокруг promise-ов (если бы он использовался на практике) становится гораздо более запутанным и сложным.

Однако представление функций, поддерживающих асинхронное выполнение, уже существует и это - корутины (coroutines, сопрограммы).
Введённые в 1958 году Мелвином Конвейем (Melvin Conway) корутины по существу представляют собой функции, которые могут приостанавливать и возобновлять своё выполнение; именно то что необходимо для `async`-функций.
Широко использовавшиеся в ранние годы программирования, присутствующие в таких языках как Simula и Modula-2, с появлением многопоточного программирования, о котором говорилось во введении, они отошли на второй план.
Но теперь они вновь вернулись в роли базового блока асинхронного программирования.

Корутины это то, что лежит в основе реализации async/await в большинстве языков программирования, и Kotlin не исключение;
В разных языках, однако, могут использоваться разные варианты корутин.
Основы корутин и отличительные особенности их применения в Kotlin обсуждаются в разделах 3 и 4 соответственно.

2.4 Green Threads (легковесные потоки, пользовательские потоки)

Другим подходом к асинхронному программированию является использование так называемых _green threads_ (зелёных потоков).
Это легковесные потоки (или процессы) управление которыми происходит в пользовательском пространстве, а не пространстве ядра.
Первым языком, в котором они появились был occam, созданный в 1983 и в значительной степени вдохновленный алгеброй взаимодействующих последовательных процессов (CSP, communicating sequential processes).
В Concurrent ML CSP было расширено синхронными абстракциями первого класса, как полезным механизмом для упрощения асинхронного программирования.

В настоящее время легковесные потоки лежат в основе реализации асинхронного программирования в Erlang, Go и Stackless Python.
Пример реализации `guessWebPageLocale` на Go преведён в листинге 4.
Ключевое слово `go` используется для выполнения функции в легковесном потоке, который в Go называется _goroutine (горутина)_.

Хотя программы, использующие этот стиль программирования, напоминают традиционные многопоточные, есть несколько важных отличий, связанных с их асинхронной природой.
Во-первых, легковесные потоки поддерживают кооперативную (или невытесняющую) многозадачность, т.е. программа сама сигнализирует, когда её можно приостановить.
Хотя существует опасность того, что одна дефектная программа заблокирует выполнение, преимущество более эффективного переключения между легковесными потоками (по сравнению со встроенными (native)) обычно перевешивает возможные недостатки.

Во-вторых, предпочтительным способом обмена данными является передача сообщений по каналам.
Предоставляя встроенные, эффективные средства передачи сообщений, языки с легковесными потоками пытаются конкурировать по производительности с техникой разделяемой памяти (shared memory), одновременно сокращая количество потенциальных проблем.
Однако при неправильном использовании этот механизм может быть столь же подвержен ошибкам, как и использование разделяемой памяти.

Если мы сравним легковесные потоки с `async`/`await`, то обнаружим, что как подходы к асинхронному програмированию они двойственны друг к другу.
Реализации async/await стремятся сделать асинхронный код как можно более похожим на обычный, однопоточный, синхронный код.
Легковесные потоки, с другой стороны, делают то же самое, но в направлении традиционного многопоточного кода.
Какой из этих подходов лучше (с точки зрения программиста) является предметом споров.
Но для эффективной поддержки легковесных потоков язык программирования должен быть либо построен на них изначально (как Go и Erlang), либо значительно изменён (как Stackless).
По этой причине большинство языков, которые включают поддержку асинхронного программирования на более поздних этапах своего развития, выбирают подход `async`/`await`.

2.5 Проблемы асинхронного программирования

2.5.1 Раскраска функций (function colouring)

Важное отличие между разными реализациями асинхронных вычислений заключается в том, поддерживает ли данная реализация чёткое разделение между асинхронным и синхронными кодом, которое мы будем называть _цветом кода_ (или функции).
Это распространенная идиома, которая встречается в разных формах, но, по сути, сводится к ряду простых правил:
* Каждой функции (или, в некоторых случаях, фрагменту кода) присваивается определённый цвет: в данной статье мы будем использовать красный и синий;
* Синий код представляет синхронные вычисления и доступен из кода обоих цветов;
* Красный код представляет асинхронные вычисления и доступен только из (другого) красного кода;
* Существуют специальные конструкции, позволяющие вызывать красный код из синего; или точка входа в пользовательский код (`main`) имеет красный цвет.

В общем случае, при использовании бОльшего количества цветов и правил их взаимодействия, раскраска кода может быть применена к ряду различных проблем.
В разделе 7.1 приведён краткий обзор таких подходов.
В оставшейся части статьи термин _раскраска функций_ будет использоваться только в контексте проблем относящихся к асинхронным вычислениям и только с приведеными выше цветами.

_Раскраска кода_ очень похожа (и может рассматриваться как частный случай) на вычисления с коэффектами (coeffects), а гарантии, которые она обеспечивает, очень похожи на функциональные монады (например, монаду IO в Haskell).

Почему вообще _раскраска кода_ важна для асинхронных вычислений?

В принципе, можно представить себе язык, в котором весь код - _красный_, а все вычисления могут быть асинхронными.
Но на самом деле это порождает ряд проблем.
* Асинхронные вычисления ведут к дополнительным накладным расходам;
* Большинство языков программирования по своей природе синхронны, а внедрение асинхронных конструкций служит определенной цели.
Отсутствие явного разграничения между синхронными и асинхронными функциями затрудняет осмысление программы:
чтобы понять какой является данная функция нужно проанализировать (настолько глубоко, насколько это необходимо) реализацию каждой задействованной программной сущности.
Это особенно проблематично, когда асинхронные вычисления используются совместно с многопоточностью;
* Обработка и пробрасывание ошибок (в виде исключений или другого механизма) в _красном коде_ — особенно сложная задача (подробности см. в разделе 2.5.2).
Когда весь код _красный_, то продвинутая обработка ошибок должна использоваться всегда.

С другой стороны, если решить эти проблемы, то _бесцветный_ язык будет обладать гибкостью позволяющей добавить _раскраску кода_, в виде отдельной библиотеки или расширения, если и где это необходимо.
Проект OpenJDK Loom стремится достичь эту амбициозную цель в JVM (Java virtual machine).

2.5.2 Обработка ошибок.

Ещё одной важной проблемой асинхронного программирования является обработка ошибок.
Когда одновременно выполняется несколько асинхронных операций, и одна из них завершается с ошибкой, то восстановление и продолжение работы является не такой простой задачей, как в синхронном коде.

В обычном коде есть однозначное отношение между вызываемым и вызывающим: ошибки в вызываемом коде распространяются _вверх_ к вызывающему и там обрабатываются или распространяются дальше.
В асинхронном коде этой связи больше нет и поэтому сложно определить кто какие ошибки обрабатывает.
Также может потребоваться распространить обработку ошибок _вниз_, например, для отмены ненужных вычислений.

Доступные в языке средства могут быть использованы для создания замены встроенной обработки ошибок: для callback-ов может быть предоставлен специальный обработчик; для promise-ов может быть использован конвеер (pipelining); реализации `async`/`await` обычно поддерживают блоки `try`/`catch`.
Однако всё это плохо работает с нисходящей обработкой ошибок (для чего потребовалось бы много шаблонного кода).

Более принципиальный метод включал бы как восходящую, так и нисходящую обработку ошибок в асинхронной коде.
Можно выделить два подхода, которые используются в современном асинхронном программировании.
Первый, появившийся в Erlang, использует деревья процессов-наблюдателей (supervision trees).
Он основан на организации асинхронных задач в виде иерархических деревьев соответсвующих желаемой структуре распространения ошибок (восходящей и нисходящей).
В случае возникновения ошибки её можно изолировать, распространить или перезапустить затронутое поддерево задач.

Второй подход, впервые описанный в 2016 году под названием _structured concurrency_ (структурное конкурентное программирование), предлагает перенести идею структурного программирования на асинхронное следующим образом: все задачи связаны со своими создателями, и если задача A запустила задачу B, то время жизни B не может превышать время жизни A.
Эта схема устанавливает отношение запускающий-запускаемый (launcher-launchee) вместо вызывающий-вызываемый, и описывает механизм низходящего распространения ошибок и отмен (cancellations).

По сравнению с деревьями процессов-наблюдателей подход structured concurrency менее гибок, поскольку стратегия обработки ошибок фиксирована.
Однако он также менее многословен и хорошо соотносится с тем, как обычно пишется асинхронный код.
Именно по этой причине в последние годы structured concurrency привлекает всё больше внимания: его реализуют или в виде библиотек или как полноценную возможность языка.

3 Корутины как основа асинхронного программирования

В этом разделе мы рассмотрим корутины в роли базовых строительных блоков для асинхронных программ.
Мы дадим корутинам определение, рассмотрим как они связаны с continuation (континуация, продолжение) и как используются для реализации `async`/`await`.

3.1 Что такое корутины?

Насмотря на то, что в том или ином виде корутины используются уже более 50-ти лет, к удивлению, для них до сих пор не существует универсального определения.
Когда говорят о корутинах, то обычно имеют в виду что-то вроде приостанавливаемой (suspendable) функции, то есть такой которая может приостанавливать и возобновлять своё выполнение, сохраняя при этом состояние.
Эта характеристика была дана корутинам ещё в 1980-м году.

In [37], coroutines have been classified using the following axes, on which their implementations may differ.

В 37 была дана классификация свойств, которые влияют на способ реализации корутин. 

Симметричная/Ассиметричная передача управления

Симметричная корутина A может приостановиться и возобновить выполнение в произвольной корутине B.
Это означает, что можно свободно переключаться между разными корутинами, то есть передача управления - симметрична.
Асимметричная корутина (также известная как полу-корутина) может себя приостановить, но при этом, подобно обычной функции, также возобновится выполнение в месте вызова. То есть передача управления между корутинами ограничена их иерархией.
Хотя считалось, что симметричные корутины более выразительны, чем ассиметричные (поскольку они реализованы и применяются в таких языках как Simula и Modula-2), на самом деле их можно выразить посредством друг друга.
В то же время симметричные корутины гораздо сложнее для понимания, поскольку допускают неограниченную передачу управления.
Именно по этой причине большинство современных реализаций корутин являются асимметричными.
Наиболее примечательным исключением является язык Julia.

Стековые/бесстековые (stackful/stackless) реализации

Стековая реализация корутин поддерживает приостановку внутри произвольных вложенных функций;
при возобновлении стековая корутина продолжает выполнение с точки последней приостановки, восстанавливая исходный стек вызовов.
Бесстековая реализация, с другой стороны, может приостанавливать только текущую корутину;
для асинхронного выполнения вложенных функций, они также должны быть корутинами.
Внимательный читатель заметит некоторое сходство между дихотомией стековых/бесстековых корутин и проблемой раскраски функций, которую мы обсуждали в разделе 2.5.1. И это не случайно.
Если язык поддерживает стековые корутины, то у него есть возможность использовать один цвет для всего кода;
в случае бесстековых корутин поддержка вложенных точек пристановки приводит к необходимости использования двух отдельных цветов.
Однако, это различие не является обязательным, поскольку языки со стековой реализацией могут использовать несколько цветов, например, в целях повышения производительности, а бесстековые - один цвет, объявив функцию входа (`main`) асинхронной (красной).
Большинство современных языков используют бесстековые корутины.
Lua, Ruby и Julia являются одними из немногих языков с поддержкой стековых корутин.
Хотя стековые корутины и являются более мощными, бесстековые могут предоставить большинство возможностей (если не те же самые) за счёт аккуратного управления вложенными вызовами.
Также, стековые корутины значительно сложнее реализовать эффективно, что является еще одним ограничивающим фактором для их широкого применения.

Полная/ограниченная поддержка

При работе с корутинами может возникнуть желание изменить некоторые аспекты обработки асинхронного кода;
возможно ли это, зависит от того, каким типом поддержки корутин мы располагаем.
Языки с ограниченной поддержкой не позволяют разработчикам манипулировать корутинами в явном виде, т.е. они скрыты какой-то абстракцией;
большинство реализаций `async`/`await` относятся к этой категории.
Например, конфигурирование `async`/`await` в C# ограничено предоставляемым для этого API;
в других случаях (JavaScript, Dart) такой возможности нет вообще.
Полная (first-class) поддержка означает возможность прямого доступа к корутине как к сущности первого класса: её можно сохранять в переменную, передавать между функциями, приостанавливать/возобновлять по запросу (как в Lua или Julia).
Всё это обеспечивает дополнительную выразительность и гибкость, например, возможность альтернативной реализации кооперативной многозадачности.
С другой стороны, платой за это будет дополнительная сложность кода.

[kotlin]: https://kotlinlang.org/
[kcoroutines]: https://kotlinlang.org/docs/coroutines-overview.html
