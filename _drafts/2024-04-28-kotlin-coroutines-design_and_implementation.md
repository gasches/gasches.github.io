---
layout: post
title:  Kotlin Coroutines: Design and Implementation
date:   2024-04-28 00:00:00 +0000
categories: kotlin coroutines
---
> Roman Elizarov, Mikhail Belyaev, Marat Akhin, and Ilmir Usmanov. 2021. Kotlin Coroutines: Design and Implementation. In Proceedings of the 2021 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (Onward! ’21), October 20–22, 2021, Chicago, IL, USA. ACM, New York, NY, USA, 17 pages. https://doi.org/10.1145/3486607.3486751. Вольный перевод

* TOC:
{:toc}

## Aннотация

Асинхронное программирование переживает ренессанс в последние годы. Созданное в 1980-х оно применялось довольно долгое время, но с появлением многоядерных процессоров было вытеснено многопоточным программированием, которое (на очень долгое время) фактически стало стандартном для реализации параллельных вычислений. Однако, начиная с 2000-х, все больше языков программрования начали поддерживать асинхронность. Некоторые - с самого начала, в то время как другие внедряли поддержку в ходе развития.

В этой статье исследуются дизайн и реализация асинхронного программирования в [Kotlin][kotlin] - мультиплатформенном языке программирования от JetBrains, в котором асинхронность реализована с помощью [корутин (coroutines, сопрограмма)][kcoroutines]. Koltin предоставляет компактный встроенный API для поддержки корутин давая разработчику большую свободу для имплементации. Эта гибкость делает возможной _прозрачную_ поддержку различных вариантов реализации асинхронного программирования в рамках одного языка.

В статье кратко рассмотрены существующие подходы к асинхронному программированию, а основной упор сделан на корутины как основу реализации асинхронных вычислений в Kotlin. В ходе исследования будет показана гибкость корутин в Kotlin, освещены некоторые существующие проблемы асинхронного программирования и то как с ними справляется Kotlin. Также будут упомянуты перспективные направления в исследовании асинхронного программирования.

## 1 Введение

Рациональное использование аппаратных средств давно является одной из главных проблем программирования.
Для эффективной утилизации современных процессоров наши программы (среди прочего) должны поддерживать одновременное выполнение нескольких вычислений: пока одни делают полезную работу, другие могут ждать данных или результатов других вычислений.

Многопоточность (multithreading) традиционно применялась для распараллеливания вычислений, когда каждое такое вычисление выполняется в отдельном потоке (thread).
Если вычислению нужно подождать чего-то, то поток блокируется для освобождения ресурсов процессора, и позже возобновляется когда необходимые результаты уже готовы.
Хотя такая модель и решает проблему, она имеет несколько недостатков, таких как сложность программирования и снижение производительности для задач, связанных с вводом-выводом (IO-bound).

Альтернативой многопоточности являются различные виды асинхронного программирования.
В отличие от многопоточности, которая основана на гомогенных (coarse-grained) потоках, асинхронное программирование реализовано средствами гетерогенных (fine-grained) приостанавливаемых (suspendable) вычислений, которые могут эффективно переплетаться друг с другом (обеспечивая лучший уровень конкурентности (concurrency)).
Однородный, однообразный
Многие из ранних языков программирования имели поддержку асинхронного программирования, но с распространением многоядерных процессоров она была практически полностью вытеснена многопоточностью.

Однако, в последние годы наступил момент своего рода "ренессанса", так как всё больше языков начали опять включать поддержку асинхронного программирования.
Причиной этому может быть то, что оно лучше подходит для современных приложений которым приходится много ждать: ввода данных пользователем, сетевых пакетов и т.д.
Языки программирования поддерживают асинхронность по-разному, в зависимости от целей дизайна и их эволюции.

В этой статье исследуются дизайн и реализация асинхронного програмирования в [Kotlin][kotlin] - мультиплатформенном языке программирования от JetBrains, в котором асинхронность реализована с помощью [корутин (coroutines)][kcoroutines].
Его поддержка аснхронного программирования в некоторой степени уникальна, потому что сам Kotlin предоставляет компактный набор встроенного асинхронного API, а бОльшая часть реализации представлена в виде пользовательских библиотек.
Эта позволяет поддержать различные виды асинхронного программирования в рамках одного языка, давая разработчику большую свободу для имплементации.

Оставшаяся часть статьи реализована следующим образом.
Во втором разделе рассматриваются существующие подходы для асинхронного программирования и их проблемы.
В третьем разделе сделан фокус на корутинах.
В четвёртом разделе производится анализ дизайна и реализации корутин в Kotlin, а в пятом - приведены множество примеров гибкости выбранного подхода.
После этого в разделе 6 рассмотрены текущие ограничения, а в седьмом - открытые вопросы дизайна.

2 Способы реализации асинхронного программирования

На протяжении многих лет предпринимались попытки снабдить языки программирования средствами для поддержки асинхронности.
Здесь, чтобы предоставить контекст для лучшего понимания дизайна и реализации корутин в Kotlin, мы рассмотрим наиболее важные из них.

2.1 Callbacks (функции обратного вызова)

Callback-и - это, пожалуй, самый распространенный способ организации программ с асинхронными вычислениями.
По сути - это функция передаваемая (как лямбда-выражение, ссылка, указатель и т.д.) соответствующему API с намерением быть вызванной при выполнении некоторого условия (например, готовности результата асинхронного вычисления).
Callback-и могут использоваться для поддержки как синхронных (например, для обработки ошибок) так и асинхронных моделей выполнения.
Они особенно широко распространены в системном программировании как средство для взаимодействия с асинхронным API предоставляемым операционной системой, таким как сигналы Unix.

Callback-и удобны для выражения отдельных асинхронных взаимодействий в синхронном коде.
Однако, в более сложных сценариях, фреймворки основанные на callback-ах как известно приводят к такому усложнению структуры кода, что оно несоответствует сложности логики, которую этот код выражает (так называемый "callback hell").
Это особенно заметно в языках программирования с поддержкой анонимных или локальных функций где _callback hell_ приводит к глубоко вложенной структуре и/или множеству небольших именованных локальных функций, которые очень трудно поддерживать или изменять.
Пример того как API основанный на обратных вызовах приводит к появлению вложенного и сложного кода, приведён в листинге 1.

```javascript
fs.listDirectory(target) { files ->
    for (file in files) {
        file.readText { text ->
            sendMessage(peer, text) { answer ->
                database.store(answer) { result ->
                    if (result.error) error (result.error)
                }
                sendMessage (leader, 'done') { answer ->
                    log(answer)
                }
            }
        }
    }
}
```

Callback-и, при этом, имеют одно очень важное преимущество перед другими подходами к асинхронному программированию: фреймворки, основанные на обратных вызовах, гораздо проще в реализации и использовании при отсутствии явной поддержки со стороны языка.

2.2 Futures/Promises

Future-и или promise-ы (также иногда называемые deferred-ами or task-ами) стоят на ступень выше вычислений на основе callback-ов, работая как специальные прокси для еще не завершённых результатов асинхронных вычислений.
Базовый, но при этом полный набор операций, которые можно выполнить над promise-ом, состоит из двух:
* проверки на завершение и
* получении конечного результата.
Попытка получить результат ещё не завершённого promise-а, в зависимости от реализации, либо блокирует выполнение программы до тех пор, пока результат не будет готов, либо приводит к ошибке времени выполнения.

Хотя оба термина используются взаимозаменяемо кажется, что термин future более распространён для прокси-объектов с результатом доступным только для чтения, в то время как promise - для прокси-объектов которые можно завершить (fulfil) извне.
Здеь и далее термин promise будет использоваться для описания прокси обоих типов.

Основная проблема приведенных выше _базовых_ promise-ов заключается в неспособности простым способом выразить полностью асинхронные вычисления: имея базовый набор операций приходиться или синхронно блокировать выполнение ожидая завершение каждого из promise-ов (что противоречит цели асинхронного программирования) или вводить собственную реализацию цикла обработки событий (event loop) в котором периодически проверять состояние активных promise-ов.
Это ведёт к загромождению пользовательского кода шаблонными конструкциями.

Расширением концепции promise-ов является их организация в виде конвеера (pipelining): этот термин был введен в обиход благодаря языку программирования Joule, но сама идея изначально сформулирована в [33].
Техника конвейеризации promise-ов вводит примитивы композиции, благодаря которым становится возможным создание составных результатов из различных асинхронных вычислений без явного ожидания каждого из них.
Такие примитивы могут включать запуск произвольного кода при завершении вычисления или создание нового результата из нескольких незавершённых (который будет вычислен при их завершении).
Те, кто имеет опыт использования функциональных языков программирования могут заметить, что конвейеризация даёт возможность promise-у реализовать функциональную монаду с дополнительной возможностью использовать существующий основанный на монадах шаблонный код.

С точки зрения программиста, конвейеризация promise-ов является смесью callback-ов и основанных на promise-ах вычислений, поскольку примитивы высшего порядка, используемые большинством вычислений с конвейерной обработкой, в качестве функции которую нужно запустить при готовности всех требуемых результатов принимают callback.
Тем не менее, это позволяет выражать "по-настоящему" асинхронные вычисления без использования явной блокировки или циклов обработки событий (event loops), также частично устраняя проблему "callback hell".

Пример который иллюстрировал "callback hell", но с использованием преимуществ конвейеризации promise-ов приведён в листинге 2.

```javascript
fs.listDirectory(dir)
    .thenApply { files ->
        files.map { file ->
            file.readText()
                .thenCompose { text ->
                    sendMessage(peer, text)
                }.thenCompose { answer ->
                    database.store(answer)
                }.thenRun { result ->
                    if (result.error) error(result.error)
                }.thenCompose { result ->
                    sendMessage(leader, 'done')
                }.thenApply { answer ->
                    log(answer)
                }
        }.let { allOf(it) }
}
```

В нём используются наименования из стандартной библиотеки Java 8 (а именно из класса `CompletableFuture`, который реализует конвейерный promise);
следуя традиционному наименованию API монад `thenApply` может быть заменён на `map`, а `thenCompose` - на `flatMap`.
Хотя версия функции на основе promise-ов длиннее, она лучше выражает отношения между операциями и является менее вложенной.
Однако она все ещё загромождена обеспечивающими асинхронность специфичными вызовами функций и ненужными лямбда-выражениями.

2.3 async/await

Естественным улучшением таких техник как callback-и and promise-и было бы сглаживание различий между синхронным и асинхронным кодом.
Асинхронный код обычно сложнее осмыслить, чем синхронный, а дополнительная многословность callback-ов and promise-ов (не будучи конструкциями языка программирования) делают ситуацию ещё хуже.
async/await - подход который лишён этих проблем, поскольку асинхронное программирование становится объектом первого класса (first-class citizen).

Подход async/await основан на представлении асинхронных вычислений в виде двух взаимосвязанных частей:
* `async` используется для обозначения кода (вызова функции, выражения, блока) который выполняется асинхронно;
* `await` действует в роли барьера для одного или нескольких `async`-блоков, гарантируя звершение их выполнения.

Первым широко используемым языком программирования, в котором появились `async`/`await`, был C# версии 5.0 (2012 год).
До C# подобная возможность появилась в F# версии 2.0 с его асинхронными выражениями, которые в свою очередь были вдохновлены работой над concurrency-монадой для Haskell.

В зависимости от варианта поддержки в языке, разные элементы должны быть помечены как async или await.
Например, в C# асинхронная функция, определяющая локаль веб-страницы, может выглядеть, как показано в листинге 3.
Реализация async/await в C# помечает код следующим образом:
* async - это модификатор обозначающий, что функция поддерживает асинхронное выполнение;
* await - это встроенный оператор, который ожидает завершения выполнения своего асинхронного аргумента.

В C# имеется два дополнительных ограничения касающихся его реализации async/await.
Во-первых, оператор await можно использовать только с async-функциями.
Во-вторых, возвращаемое значение async-функций должно быть ожидаемого типа, то есть типа с возможностями promise-а.

Если мы забудем об этих ограничениях и посмотрим на сам код, то увидим, что он выглядит как синхронный.
единственное, что намекает на его асинхронную природу, - это ключевые слова async/await.
Это одна из самых сильных сторон async/await по сравнению с другими подходами к асинхронному программированию: шаблонные конструкции (практически) отсутствует, код удобочитаем и его легко понять.

Многие языки программирования использовали подход C# в качестве вдохновения и следуют его реализации async/await.
JavaScript, TypeScript, Dart, Hack, Python, Rust - все эти языки используют async-функции, содержащие операторы await, которые работают с соответствующим типом promise-а.
C++20, с другой стороны, не имеет модификатора async, считая асинхронными все функции для которых используется выражение await, в то время как Kotlin выбрал обратное соглашение - с модификатором async (называемым suspend) и без встроенного оператора await.
Хотя мы еще вернёмся к этому решению в дизайне и попытаемся объяснить его в разделе 4.2, важно отметить, что, несмотря на эти различия, реализации C++ и Kotlin по-прежнему относятся к подходу async/await.

Поскольку подход к `async`/`await` в стиле C# требует, чтобы `async`-функция имела специальный тип возвращаемого значения, то `async`/`await` можно рассматривать просто как синтаксический _сахар_ над конвейеризацией promise-ов.
Однако, как только мы начнём рассматривать сложные виды порядка выполнения (например, циклы или обработку исключений) удаления синтаксического сахара (desugaring) вокруг promise-ов (если бы он использовался на практике) становится гораздо более запутанным и сложным.

Однако представление функций, поддерживающих асинхронное выполнение, уже существует и это - корутины (coroutines, сопрограммы).
Введённые в 1958 году Мелвином Конвейем (Melvin Conway) корутины по существу представляют собой функции, которые могут приостанавливать и возобновлять своё выполнение; именно то что необходимо для `async`-функций.
Широко использовавшиеся в ранние годы программирования, присутствующие в таких языках как Simula и Modula-2, с появлением многопоточного программирования, о котором говорилось во введении, они отошли на второй план.
Но теперь они вновь вернулись в роли базового блока асинхронного программирования.

Корутины это то, что лежит в основе реализации async/await в большинстве языков программирования, и Kotlin не исключение;
В разных языках, однако, могут использоваться разные варианты корутин.
Основы корутин и отличительные особенности их применения в Kotlin обсуждаются в разделах 3 и 4 соответственно.

2.4 Green Threads (легковесные потоки, пользовательские потоки)

Другим подходом к асинхронному программированию является использование так называемых _green threads_ (зелёных потоков).
Это легковесные потоки (или процессы) управление которыми происходит в пользовательском пространстве, а не пространстве ядра.
Первым языком, в котором они появились был occam, созданный в 1983 и в значительной степени вдохновленный алгеброй взаимодействующих последовательных процессов (CSP, communicating sequential processes).
В Concurrent ML CSP было расширено синхронными абстракциями первого класса, как полезным механизмом для упрощения асинхронного программирования.

В настоящее время легковесные потоки лежат в основе реализации асинхронного программирования в Erlang, Go и Stackless Python.
Пример реализации `guessWebPageLocale` на Go преведён в листинге 4.
Ключевое слово `go` используется для выполнения функции в легковесном потоке, который в Go называется _goroutine (горутина)_.

Хотя программы, использующие этот стиль программирования, напоминают традиционные многопоточные, есть несколько важных отличий, связанных с их асинхронной природой.
Во-первых, легковесные потоки поддерживают кооперативную (или невытесняющую) многозадачность, т.е. программа сама сигнализирует, когда её можно приостановить.
Хотя существует опасность того, что одна дефектная программа заблокирует выполнение, преимущество более эффективного переключения между легковесными потоками (по сравнению со встроенными (native)) обычно перевешивает возможные недостатки.

Во-вторых, предпочтительным способом обмена данными является передача сообщений по каналам.
Предоставляя встроенные, эффективные средства передачи сообщений, языки с легковесными потоками пытаются конкурировать по производительности с техникой разделяемой памяти (shared memory), одновременно сокращая количество потенциальных проблем.
Однако при неправильном использовании этот механизм может быть столь же подвержен ошибкам, как и использование разделяемой памяти.

Если мы сравним легковесные потоки с `async`/`await`, то обнаружим, что как подходы к асинхронному програмированию они двойственны друг к другу.
Реализации async/await стремятся сделать асинхронный код как можно более похожим на обычный, однопоточный, синхронный код.
Легковесные потоки, с другой стороны, делают то же самое, но в направлении традиционного многопоточного кода.
Какой из этих подходов лучше (с точки зрения программиста) является предметом споров.
Но для эффективной поддержки легковесных потоков язык программирования должен быть либо построен на них изначально (как Go и Erlang), либо значительно изменён (как Stackless).
По этой причине большинство языков, которые включают поддержку асинхронного программирования на более поздних этапах своего развития, выбирают подход `async`/`await`.

[kotlin]: https://kotlinlang.org/
[kcoroutines]: https://kotlinlang.org/docs/coroutines-overview.html
